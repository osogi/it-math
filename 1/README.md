# Task-1: Библиотека OpenMP

**Гипотеза о результатах эксперимента**

Введём несколько обозначений:
- $`t_n(x)`$ - сколько времени в условных единицах времени занимает операция $x$ при выполнении на $n$ вычислительных элементах. 
- $`net\_size`$ - размер ребра сетки, поданной на вход алгоритму.
- $`BLOCK\_SIZE`$ - размер ребра блока.
- $`iter`$ - кол-во итераций внешнего цикла в функции `processNet()`
- $`ceil(x)`$ - округлить $x$ в большую сторону 
- $`block\_num`$ = $`ceil(net\_size / BLOCK\_SIZE)`$ - 
отображает сколько нужно блоков, чтобы покрыть ребро сетки.



$`t_*(processBlock) \approx k*BLOCK\_SIZE^2,\ k \in R`$

$`t_1(processNet) \approx 
iter*( 
    t_*(processBlock)*block\_num^2 + c*block\_num),
    \ c \in R `$

$`t_n(processNet) \approx 
iter*( 
    \displaystyle\sum_{i=1}^{block\_num-1}
    t_*(processBlock)*ceil(i/n) +
    \displaystyle\sum_{i=1}^{block\_num}
    t_*(processBlock)*ceil(i/n)
    + c*block\_num)`$ 
    
$` = iter*(  
    2*t_*(processBlock)*\displaystyle\sum_{i=1}^{block\_num-1}
    ceil(i/n) +  
    t_*(processBlock)*ceil(block\_num/n) + c*block\_num),
    \ c \in R`$


На основе этих расчётов была построена таблица для расчётов предположительного ускорения.

<details>
<summary>Изображение таблицы</summary>
  
![изображение-таблицы](https://github.com/osogi/it-math/assets/66139162/30b2f719-5d4a-4304-9bdc-6ea18e9e52d4)

</details>

---

**Условия эксперимента**

Код запускался для получения аппроксимации функции $u(x, y) = 1000x^3 + 2000y^3$. 
Формула $f(x, y)$, которая задаёт для задачи граничные случаи, будет следующей $f(x, y) = 6000x + 12000y$

Эксперимент проводился на машине с ОС `Ubuntu 20.04.5 LTS x86_64`, библиотеки `Open MPI 4.0.3`, на процессоре `AMD Ryzen 7 4700U`

**Результаты эксперимента**

Результаты приведены в [таблице](https://docs.google.com/spreadsheets/d/1GOqnumgfG_rEHWf4pcUC55-rTDGwcXybQw8Ur8HrvaQ/edit#gid=0)
<details>
<summary>Изображение таблицы</summary>
  
![изображение-таблицы](https://github.com/osogi/it-math/assets/66139162/cd4f38b0-4a25-437e-86b1-6d08f83f02b4)

</details>

**Оценка полученного результата**
- В экспериментах с малыми сетками время при параллельном выполнении алгоритма не сокращается относительно
времени при последовательном выполнении. Связано это с тем что размер блока слишком большой
(относительно размеров сетки) и блок почти полностью покрывает сетку. Что сильно снижает параллелизм.
Эту "проблему" можно было решить если выбирать размер блока в зависимости от размеров сетки,
а не использовать фиксированный для всех случаев.
- Ускорение при экспериментах с большими размерами сетки, оказывается стабильно больше чем половина 
 числа вычислительных элементов.
- Если сравнивать с теоретически ожидаемым ускорением, то отношение "полученное ускорение"/"ожидаемое ускорение" будет >= 0.7 для всех экспериментов, что доказывает эффективность алгоритма. Так как в книге "высокопроизводительные вычисления для многоядерных многопроцессорных систем" результат экспериментов, где алгоритм достигал 0.75 ускорения от максимально возможного, считался эффективным.

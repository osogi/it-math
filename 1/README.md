# Task-1: Библиотека OpenMP

## Цель эксперимента
Исследовать "эффективность" реализации алгоритма 11.6,
оценив ускорение полученное при запуске на нескольких потоках.

## Условия эксперимента

Эксперимент проводился на машине с ОС `Ubuntu 20.04.5 LTS x86_64`, библиотеки `Open MPI 4.0.3`, на процессоре `AMD Ryzen 7 4700U`,
 программа собиралась компилятором `gcc 9.4.0` с флагами указанными в [Makefile](./Makefile)


Код запускался для получения аппроксимации функции $u(x, y) = 1000x^3 + 2000y^3$. 
Формула $f(x, y)$, которая задаёт для задачи граничные случаи, будет следующей $f(x, y) = 6000x + 12000y$

<details>
<summary>Почему выбор тетовой краевой задача несущественен?</summary>
  
Заметим, что краевая задача задаёт только начальное состояние системы (сетки), что для эксперимента по измерению времени влияет только на количество итераций. Но так как алгоритм предполагает одинаковый результат и количество итераций при любом запуске и любом количестве потоков. Количество итераций при запуске на одном потоке и множестве будет одинаковым, что не влияет на ускорение. Так как оно вычисляется как отношение двух величин (время при запуске на одном потоке и нескольких), значение каждой из которых прямо пропорционально количеству итераций.

</details>

## Теоретические ожидания о результатах эксперимента**

Опираясь на результаты из книги "высокопроизводительные вычисления для многоядерных многопроцессорных систем", можно получить оценку отношения "реальное ускорение"/"максимально возможное ускорение", оно приблизительно равно 0,75. Следовательно, вычислив максимальное ускорение, можем получить значения, которые стоит ожидать. За интервал, в который должно попасть реальное значение ускорения, возьмём интервал от $`0,75*максимально\_возможное\_ускорение*0,9`$ до $`0,75*максимально\_возможное\_ускорение*1,1`$.

Для расчёта максимально возможного ускорения введём несколько обозначений:
- $`t_n(x)`$ - сколько времени в условных единицах времени занимает операция $x$ при выполнении на $n$ вычислительных элементах. 
- $`net\_size`$ - размер ребра сетки, поданной на вход алгоритму.
- $`BLOCK\_SIZE`$ - размер ребра блока.
- $`iter`$ - кол-во итераций внешнего цикла в функции `processNet()`
- $`ceil(x)`$ - округлить $x$ в большую сторону 
- $`block\_num`$ = $`ceil(net\_size / BLOCK\_SIZE)`$ - 
отображает сколько нужно блоков, чтобы покрыть ребро сетки.



$`t_*(processBlock) \approx k*BLOCK\_SIZE^2,\ k \in R`$

$`t_1(processNet) \approx 
iter*( 
    t_*(processBlock)*block\_num^2 + c*block\_num),
    \ c \in R `$

$`t_n(processNet) \approx 
iter*( 
    \displaystyle\sum_{i=1}^{block\_num-1}
    t_*(processBlock)*ceil(i/n) +
    \displaystyle\sum_{i=1}^{block\_num}
    t_*(processBlock)*ceil(i/n)
    + c*block\_num)`$ 
    
$` = iter*(  
    2*t_*(processBlock)*\displaystyle\sum_{i=1}^{block\_num-1}
    ceil(i/n) +  
    t_*(processBlock)*ceil(block\_num/n) + c*block\_num),
    \ c \in R`$

На основе выше изложенных расчётов была построена [таблица](https://docs.google.com/spreadsheets/d/1GOqnumgfG_rEHWf4pcUC55-rTDGwcXybQw8Ur8HrvaQ/edit#gid=1448096775) для расчётов предположительного ускорения.

<details>
<summary>Изображение таблицы</summary>
  
![изображение-таблицы](https://github.com/osogi/control-hazard-analyzer/assets/66139162/278aaaad-b146-40ed-ac3d-2d44cdbd151d)

</details>

---

## Результаты эксперимента

Было проведено 20 экспериментов по замеру времени на сетках разных размеров при запуске алгоритма на 1 и 8 потоках. После устранения выбросов для дальнейших расчётов были взяты средние арифметические значения оставшихся экспериментов. Подробнее с этим можно ознакомиться [в этой части таблицы](https://docs.google.com/spreadsheets/d/1GOqnumgfG_rEHWf4pcUC55-rTDGwcXybQw8Ur8HrvaQ/edit#gid=0&range=Q18).


Итоговые результаты приведены в [таблице](https://docs.google.com/spreadsheets/d/1GOqnumgfG_rEHWf4pcUC55-rTDGwcXybQw8Ur8HrvaQ/edit#gid=0)

<details>
<summary>Изображение таблицы</summary>
  
![изображение-таблицы](https://github.com/osogi/control-hazard-analyzer/assets/66139162/d07bdb67-17b4-4c30-a07a-5f9fd6887c75)

</details>

## Оценка полученного результата

Почти все полученные значения ускорения оказались в ожидаемых интервалах. Исключение составили ускорения для сеток размера 100 и 500, они превысили верхнюю границу интервала. Но если взять значение времени из 95% доверительного интервала, то можно получить ускорение лежащее в ожидаемом интервале. Но скорее всего эти исключения вызваны неточной оценкой ожидаемого ускорения.

По итогу эксперимента, считаю реализацию алгоритма эффективной, так как результаты экспериментов либо попадают в ожидаемые значения, либо превосходят их (что тоже подтверждает эффективность).

<details>
<summary>Комментарий про малый размер сетки и большой размер блока</summary>
  
В экспериментах с малыми сетками время при параллельном выполнении алгоритма не сокращается относительно
времени при последовательном выполнении. Связано это с тем что размер блока слишком большой
(относительно размеров сетки) и блок почти полностью покрывает сетку. Что сильно снижает параллелизм.
Эту "проблему" можно было решить если выбирать размер блока в зависимости от размеров сетки,
а не использовать фиксированный для всех случаев.

</details>



